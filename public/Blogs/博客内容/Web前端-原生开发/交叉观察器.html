<article class="专题简介">
  <h1 class="简介标题">交叉观察器<span class="原创">原创</span></h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本">待定</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributers/Extreme Hunter.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://github.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.deviantart.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dev"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.freecodecamp.org/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://codepen.io/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://dribbble.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.artstation.com/user-7893655"
        target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://codesandbox.io/u/suyangzuo"
        target="_blank"
      >
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">交叉观察器简介</h2>

    <h3 class="分区标题 分区3级标题">设计的初衷</h3>
    <p class="分区普通文本">现代网站上经常有下列需求：</p>
    <ul class="分区列表">
      <li class="分区列表项">某个元素滚动到视口内，运行一段动画</li>
      <li class="分区列表项">页面无限滚动，一边滚动一边加载新的内容</li>
      <li class="分区列表项">页面滚动时加载资源</li>
    </ul>
    <p class="分区普通文本">
      早前都是使用事件循环来实现这样的需求，比如：在滚动时不断计算元素的<span
        class="行内专业名词"
        >边界矩形<span class="附加说明"
          ><span class="行内代码">getBoundingClientRect()</span></span
        ></span
      >。但是，<span class="行内专业名词">JavaScript</span>是一门<span
        class="行内专业名词"
        >单线程</span
      >语言，这意味着每次滚动所触发的代码程序，都会运行在<span
        class="行内专业名词"
        >主线程</span
      >上，这会严重影响网站的性能，用户的浏览体验变得很糟糕。
    </p>
    <p class="分区普通文本">
      为了解决这个问题，在 2017年9月，<span class="行内专业名词">Google</span
      >提出了<a
        class="超链接"
        target="_blank"
        href="https://www.w3.org/TR/2017/WD-intersection-observer-20170914/"
        >第一份交叉观察器的公开工作草案</a
      >。经过多年的发展，现代浏览器已经能够很好地支持交叉观察器。
    </p>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">使用交叉观察器</h2>

    <h3 class="分区标题 分区3级标题">观察器选项</h3>
    <p class="分区普通文本">要使用交叉观察器，首先需要定义几个选项：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="专业名词">视口元素<span class="行内代码">root</span></span
        >：用作<span class="行内专业名词">观察器的视口</span
        >，必须是观察目标的祖先；如果不指定，则<span class="行内专业名词"
          >默认为浏览器视口</span
        >。
      </li>
      <li class="分区列表项">
        <span class="专业名词"
          >视口元素边距<span class="行内代码">rootMargin</span></span
        >：用来扩大或缩小观察器视口。如果不指定，则<span class="行内专业名词"
          >默认为<span class="行内代码">0</span></span
        >。
      </li>
      <li class="分区列表项">
        <span class="专业名词">阈值<span class="行内代码">threshold</span></span
        >：一个数字或一组数字，指定了目标在视口元素内出现多少才算<span
          class="行内专业名词"
          >交叉</span
        ><span class="附加说明">即执行回调</span>。如<span class="行内代码"
          >0.5</span
        >，意味着目标在视口元素内达到<span class="行内专业名词">50%可见</span
        >时，就执行回调。如果不指定，则<span class="行内专业名词"
          >默认为<span class="行内代码">0</span></span
        >，意味着目标只要在视口元素内出现<span class="行内代码">1</span
        >像素，就执行回调。
      </li>
    </ul>

    <h3 class="分区标题 分区3级标题">观察器回调</h3>
    <p class="分区普通文本">
      当目标元素与视口元素<span class="行内专业名词">交叉</span>时，执行的函数。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">观察器条目</h3>
      <p class="分区普通文本">
        观察器可以同时观察多个目标，一个目标就会产生一个条目，因此在回调中，会自动接收一个参数叫<span
          class="行内专业名词"
          >条目集合<span class="附加说明"
            ><span class="行内代码">entries</span></span
          ></span
        >，这是一个可迭代对象。
      </p>
      <p class="分区普通文本">
        <span class="强调">注意：</span>即使只观察<span class="行内专业名词"
          >1</span
        >个元素，传入的参数依然是<span class="行内代码"
          >entries<span class="附加说明">复数</span></span
        >，尽管这个集合中只有<span class="行内专业名词">1</span>个条目。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">交叉观察器代码范例</h3>
    <p class="分区普通文本">假设我们有这样的元素：</p>
    <figure class="截图容器" style="height: 450px">
      <img
        style="height: calc(100% - 41px)"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-初始状态.png"
        alt="交叉观察器-初始状态"
      />
    </figure>
    <p class="分区普通文本">
      现在，我们需要观察<span class="行内专业名词">被观察元素</span>是否与<span
        class="行内专业名词"
        >视口元素</span
      >交叉。大多数情况下，<span class="行内专业名词">视口元素</span
      >都会设置为<span class="行内专业名词">浏览器视口</span
      >，因此我们用一个黄色边框模拟浏览器视口。
    </p>
    <p class="分区普通文本">
      大多数情况下，<span class="行内专业名词">4</span
      >步即可写出一个完整的交叉观察器。
    </p>
    <ol class="分区列表 有序列表">
      <li class="分区列表项">编写选项</li>
      <li class="分区列表项">编写回调函数</li>
      <li class="分区列表项">生成观察器</li>
      <li class="分区列表项">设置观察对象</li>
    </ol>
    <pre class="line-numbers">
      <code class="lang-js">
        const 被观察元素 = document.querySelector(".被观察元素");

        const 选项 = {
          root: null, //视口元素：必须是被观察元素的祖先；不写或设置为"null"，root就是浏览器视口
          rootMargin: "0px", //视口元素外边距：不写相当于设置为0，表示视口保持原本的大小
          threshold: 1, //阈值：1代表100%，意味着被观察元素必须越过"100%可见"的阈值，才会触发回调
        };

        function 回调(条目集合) {
          //每个条目代表一个被观察元素，即使只有一个，传入的参数也是集合
          条目集合.forEach(() => {
            显示回调动画();
          });
        }

        //生成交叉观察器，参数就是回调和选项
        const 观察器 = new IntersectionObserver(回调, 选项);

        //设置观察哪些元素，可以一次性传入多个被观察元素
        观察器.observe(被观察元素);
      </code>
    </pre>

    <h3 class="分区标题 分区3级标题">触发回调的时机</h3>
    <p class="分区普通文本">
      只要跨过<span class="行内代码">threshold</span
      >这条分界线，就会触发回调。让我们来滚动页面，看看<span
        class="行内专业名词"
        >阈值为<span class="行内代码">100%</span></span
      >到底是什么意思：
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-百分之百-触发回调.webp"
        alt="交叉观察器-100%-触发回调"
      />
    </figure>
    <p class="分区普通文本">
      被观察元素只要<span class="行内代码">100%</span
      ><span class="强调">跨过</span>视口，就会<span class="行内专业名词"
        >触发回调</span
      >；这个<span class="行内代码">100%</span>是在<span class="行内专业名词"
        >选项</span
      >的<span class="行内代码">threshold</span
      >属性中设置的。当被观察元素自身的<span class="行内代码">100%</span
      >处于视口元素内部时，其状态为<span class="行内专业名词">交叉中</span
      >；被观察元素位于视口元素内的部分不足<span class="行内代码">100%</span
      >，状态为<span class="行内专业名词">未交叉</span>。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">
        <span class="强调">进</span><span class="次要">与</span
        ><span class="强调">出</span>都算跨过<span class="行内专业名词"
          >阈值</span
        >
      </h3>
      <p class="分区普通文本">
        相信你已注意到，不是只有<span class="行内专业名词"
          >从外到内<span class="附加说明">未交叉 &#10145; 交叉中</span></span
        >才会触发回调，<span class="行内专业名词"
          >从内到外<span class="附加说明">交叉中 &#10145; 未交叉</span></span
        >同样会触发。你可以把阈值想象成一条<span class="强调">分界线</span
        >，只要越过分界线，不论从内到外，还是从外到内，都会触发回调函数。
      </p>
      <figure class="截图容器">
        <video
          class="video-js"
          loop
          muted
          autoplay
          preload="auto"
          poster="/Images/Blogs/Web前端-原生开发/交叉观察器/九品芝麻官-poster.png"
          data-setup='{
          "fluid": true
        }'
        >
          <source
            src="/Images/Blogs/Web前端-原生开发/交叉观察器/九品芝麻官-反复横跳.mp4"
            type="video/mp4"
          />
        </video>
      </figure>
      <p class="分区普通文本">
        黄线就是视口边界，反复横跳的结果，怎一个惨字了得。
      </p>
    </section>
    <p class="分区普通文本">
      让我们再观察一个<span class="行内专业名词">阈值</span>为<span
        class="行内代码"
        >50%</span
      >的案例。为了让视觉效果更加直观，我在<span class="行内代码">50%</span
      >的位置加了一条横线：
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/被观察元素-百分之五十-示意图.png"
        alt="被观察元素-50%-示意图"
      />
    </figure>
    <p class="分区普通文本">
      横线代表<span class="行内代码">50%</span>的位置。为了设置<span
        class="行内代码"
        >50%</span
      >的阈值，我们需要修改选项中的<span class="行内代码">threshold</span>：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        const 选项 = {
          root: null,
          rootMargin: "0px",
          threshold: 0.5, //阈值：0.5代表50%，意味着被观察元素必须越过"50%可见"的阈值，才会触发回调
        };
      </code>
    </pre>
    <p class="分区普通文本">现在，让我们来观察效果：</p>
    <figure class="截图容器">
      <img
        style="height: clamp(500px, 80vh, 950px)"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-阈值-百分之五十.webp"
        alt="交叉观察器-阈值-百分之五十"
      />
    </figure>
    <p class="分区普通文本">
      看懂了吗？<span class="行内专业名词">阈值</span>控制着被观察元素的<span
        class="行内专业名词"
        >百分之多少</span
      >越过视口边界时，会触发回调。
    </p>

    <h3 class="分区标题 分区3级标题">
      只需要<span class="行内专业名词">交叉中</span>
    </h3>
    <p class="分区普通文本">
      有时，我们只想在<span class="行内专业名词">未交叉 &#10145; 交叉中</span
      >状态运行一些任务，反之则什么都不做。怎么实现呢？交叉观察器有一个非常实用的属性：<span
        class="行内专业名词"
        >交叉中<span class="附加说明"
          ><span class="行内代码">isIntersecting</span></span
        ></span
      >，此属性为<span class="行内专业名词">布尔类型</span
      >，可用来判断被观察元素与视口元素当前是否处于交叉状态。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //其它代码相同

        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            //仅当处于交叉状态时，才显示回调动画
            if (条目.isIntersecting) {
              显示回调动画();
            }
          });
        }

        //其它代码相同
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-交叉中-触发回调.webp"
        alt="交叉观察器-交叉中-触发回调"
      />
    </figure>
    <p class="分区普通文本">
      每次越过<span class="行内代码">100%</span
      >临界线时，触发回调，回调内部判断两个元素是否处于交叉状态，具体到本程序而言，会判断被观察元素是否<span
        class="行内代码"
        >100%</span
      >处于视口元素内部，<span class="行内专业名词">是</span>则显示动画。
    </p>

    <h3 class="分区标题 分区3级标题">视口元素外边距</h3>
    <p class="分区普通文本">
      视口元素外边距的作用很简单：将实际的视口向外扩展，或者向内收缩。假设我们要将实际视口向内收缩：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        const 选项 = {
          root: null,
          
          //语法和"CSS"的"margin"类似，注意：这里不能用"0"，必须用"0px"
          rootMargin: "-125px -50px", //负值表示向内收缩，上下各125像素，左右各50像素
          threshold: 0.5, //阈值：0意味着被观察元素只要有1个像素约过视口边界，就会触发回调
        };
      </code>
    </pre>
    <p class="分区普通文本">
      负值代表向内收缩，因此实际视口比视口元素要小。二者关系如下图：
    </p>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/视口元素-实际视口.png"
        alt="视口元素-实际视口"
      />
    </figure>
    <p class="分区普通文本">
      <span class="强调">注意：</span>实际视口在网页上是看不见的，图中的<span
        style="color: lightcyan"
        >亮青色</span
      >方框是我特意制作以方便观察用的。 因为水平和垂直都是<span
        class="行内专业名词"
        >负值</span
      >，因此实际视口要<span class="行内专业名词">小于</span
      >视口元素。反之，<span class="行内专业名词">正值</span>会使实际视口<span
        class="行内专业名词"
        >大于</span
      >视口元素。让我们来看看效果：
    </p>
    <figure class="截图容器">
      <img
        style="height: clamp(500px, 80vh, 950px)"
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-视口元素外边距.webp"
        alt="交叉观察器-rootMargin"
      />
    </figure>
    <p class="分区普通文本">
      当被观察元素的<span class="行内代码">50%</span
      >越过视口元素边界时，没有触发回调，因为此时真正的视口是内部的<span
        class="行内专业名词"
        >实际视口</span
      >。
    </p>

    <h3 class="分区标题 分区3级标题">多个阈值</h3>
    <p class="分区普通文本"></p>

    <h3 class="分区标题 分区3级标题">交叉比例</h3>
  </article>
</div>
